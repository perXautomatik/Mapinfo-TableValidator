include "CommonLib\commonLib1.def"
Include "MapBasic.def"

Declare sub processor_ValidatePathTable 
Declare function errorsINPathTable() as logical 
Declare function selectFailuresFrompathTable as integer
Declare sub processor_ValidateTable 
Declare sub rmNonOneAndInvalid()
Declare sub runValidation()
Declare sub Main
Declare sub loadPathArray()

global 
	G_senastTid,
    G_Progress,
    G_starttime,G_ProgressRange as integer,
	paths() as string

Sub Main

    G_senastTid = 0
    G_Progress = 0
    G_starttime = timer()

	if(errorsINPathTable()) then		
		G_ProgressRange =  tableInfo("NameNalias",TAB_INFO_NROWS)+3
		
		ProgressBar "processor_ValidateTable...." & G_ProgressRange & " items" Calling processor_ValidateTable	Range G_ProgressRange 	
	'	print Chr$(12) 'emptyScreen
		commit table PathTable
	end if	
	
end sub

sub runValidation()	
	dim val1,testPath as string ,i as integer
		
	val1 = NameNalias.col1
	for i=1 to ubound(paths)
  		testPath = paths(i) & val1
  		if(ValidateNClosePath(testPath)) then
  			val1 = iif(NameNalias.col2<>"",NameNalias.col2,left$(NameNalias.col1,len(NameNalias.col1)-4))
  			insert into pathTable (tablePath,tableName,static) values (testPath,val1,1)
  			goto found
  		end if
	next	
	found:

End Sub

sub processor_ValidateTable
	
	DO case G_Progress
		case 1
			call loadPathArray()
		case 2
			dim tempstring as string tempstring = applicationDirectory$() + "pathTable.tab"
	
			if not(ValidateNClosePath(tempstring)) then note "createintg pathTable" CREATE TABLE PathTABLE (tableName Char(40),tablePath Char(256),alternative Char(256),static Integer) File tempstring end if

			fetch first from NameNalias
		case G_ProgressRange
			if(selectFailuresFrompathTable() <> 0) then dim failerues(),failedTables as string call columnAsStringArray("Failures","col1",failerues) failedTables = StringArrayAsString(failerues) goto CouldntOpenEveryTableError end if
		case else 
			call runValidation()
			fetch Next from NameNalias
	end case
	call increment(G_Progress,G_ProgressRange,G_starttime)

    
exit sub

	CouldntOpenEveryTableError:
		note "CouldntOpenEveryTableERROR " & failedTables
		end program

end sub

sub processor_ValidatePathTable
	
	DO case G_Progress
		case 1
			Pack Table pathTable Data
			fetch first from pathTable
		case G_ProgressRange
		
			commit table NameNalias
			
			if(selectFailuresFrompathTable() <> 0) then select * from NameNalias where left$(col1,len(col1)-4) = any(select col1 from pathTable) into success delete from success end if
		
			Commit table NameNalias
		
			Pack Table NameNalias Data
			
		case else 
			call rmNonOneAndInvalid()
			
			fetch next from pathTable
	end case
	call increment(G_Progress,G_ProgressRange,G_starttime)    
exit sub

end sub

sub rmNonOneAndInvalid()	
	dim testPath as string ,val1 as integer
		
	val1 = pathTable.col4
	testPath = pathTable.col2
	
	if(val1 <> 1) then
		select * from pathTable where Col4 <> 1 into ToDelete
		Delete from ToDelete
	else
		if(not(ValidateNClosePath(testPath))) then
			select * from pathTable where testPath = Col2 into ToDelete		
			Delete from ToDelete
		end if
	end if
	
End Sub

function selectFailuresFrompathTable() as integer
		 
		select * from NameNalias where not(left$(col1,len(col1)-4) = any(select col1 from pathTable)) into failures
		
	selectFailuresFrompathTable = tableInfo("failures",TAB_INFO_NROWS)
End function
		
function errorsINPathTable() as logical
	onError goto NoTable
	open table applicationdirectory$()+ "pathTable.tab"
	
	G_ProgressRange =  tableInfo("pathTable",TAB_INFO_NROWS)+2
	ProgressBar "processor_ValidatePathTable...." & G_ProgressRange & " items" Calling processor_ValidatePathTable	Range G_ProgressRange 	
	
	dim tempInteger as integer

	tempInteger	= selectFailuresFrompathTable() 'any integer higher than zero means trur
	print "X" & tempInteger	
	errorsINPathTable = (0 <> tempInteger)
	onError goto 0

exit function
	noTable:
		print error$()
		errorsINPathTable = true
end function



sub loadPathArray()
	open Table applicationdirectory$() & "NameNalias.TAB" select left$(Col1,len(Col1)-2),Col2 from PathsPriorityOrder where right$(col1,1) = "*" order by col2 into PrefixPaths
	open Table applicationdirectory$() & "PathsPriorityOrder.TAB" select right$(Col1,len(Col1)-1),Col2 from PathsPriorityOrder where left$(col1,1) = "*" order by col2 into PostfixPaths
	
	fetch first from PrefixPaths
	dim val1 as string ,i as integer
	i = 1
	DO UNtil EOT(PrefixPaths)
		val1 = PrefixPaths.col1
		
		fetch first from PostfixPaths
		DO UNtil EOT(PostfixPaths)
			redim paths(i) paths(i) = Val1 & PostfixPaths.col1
		  	i=i +1
		    fetch Next from PostfixPaths
		 loop
		 
	    fetch Next from PrefixPaths
	 loop
	
End Sub